#!/usr/bin/env node
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});

// src/cli.ts
import meow from "meow";
import chalk from "chalk";

// src/html.ts
import path from "path";
import fs from "fs-extra";
var htmlTemplate = (diff) => `<html>
<head>
  <title>GraphQL Schema Diff</title>
  <meta charset="utf-8" />
  <link rel="stylesheet" href="css/hljs.min.css">
  <link rel="stylesheet" href="css/diff2html.min.css">
  <script src="js/highlight.min.js"></script>
  <script src="js/graphql.min.js"></script>
  <script src="js/diff2html.min.js"></script>
  <script src="js/diff2html-ui-base.min.js "></script>
</head>
<body>
  <div id="diff"></div>
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const diffString = \`${diff}\`;
      const targetElement = document.getElementById('diff');
      const configuration = {
        matching: 'lines',
        outputFormat: 'side-by-side',
        highlight: true,
        synchronisedScroll: false,
        drawFileList: false,
        rawTemplates: {
          'tag-file-renamed': '',
        }
      };
      const diff2htmlUi = new Diff2HtmlUI(targetElement, diffString, configuration, hljs);
      diff2htmlUi.draw();
    });
  </script>
</body>
</html>`;
async function createHtmlOutput(diff, options = {}) {
  const { outputDirectory = "schemaDiff" } = options;
  const adjustedDiff = diff.replace(/(---\s.*)\sremoved/, "$1").replace(/(\+\+\+\s.*)\sadded/, "$1").replace("No newline at end of file", "");
  await fs.ensureDir(outputDirectory);
  const diff2HtmlPath = path.dirname(__require.resolve("diff2html/package.json"));
  const highlightJsPath = path.dirname(
    __require.resolve("@highlightjs/cdn-assets/package.json")
  );
  await Promise.all([
    fs.copy(
      path.join(diff2HtmlPath, "bundles/js/diff2html.min.js"),
      path.join(outputDirectory, "js/diff2html.min.js")
    ),
    fs.copy(
      path.join(diff2HtmlPath, "bundles/css/diff2html.min.css"),
      path.join(outputDirectory, "css/diff2html.min.css")
    ),
    fs.copy(
      path.join(highlightJsPath, "styles/default.min.css"),
      path.join(outputDirectory, "css/hljs.min.css")
    ),
    fs.copy(
      path.join(highlightJsPath, "highlight.min.js"),
      path.join(outputDirectory, "js/highlight.min.js")
    ),
    fs.copy(
      path.join(highlightJsPath, "languages/graphql.min.js"),
      path.join(outputDirectory, "js/graphql.min.js")
    )
  ]);
  const diff2htmlUiBase = (await fs.readFile(
    path.join(diff2HtmlPath, "bundles/js/diff2html-ui-base.min.js")
  )).toString().replace('void 0!==t?t:"plaintext"', '"graphql"');
  const htmlOutput = htmlTemplate(adjustedDiff);
  await Promise.all([
    fs.writeFile(path.join(outputDirectory, "index.html"), htmlOutput),
    fs.writeFile(
      path.join(outputDirectory, "js/diff2html-ui-base.min.js"),
      diff2htmlUiBase
    )
  ]);
}

// src/diff.ts
import {
  findBreakingChanges,
  findDangerousChanges
} from "graphql";
import { lexicographicSortSchema } from "graphql/utilities/index.js";
import disparity from "disparity";
import { loadSchema } from "@graphql-tools/load";
import { UrlLoader } from "@graphql-tools/url-loader";
import { JsonFileLoader } from "@graphql-tools/json-file-loader";
import { printSchemaWithDirectives } from "@graphql-tools/utils";
import { GraphQLFileLoader } from "@graphql-tools/graphql-file-loader";
import fetch from "node-fetch";
async function getDiff(leftSchemaLocation2, rightSchemaLocation2, options = {}) {
  var _a, _b;
  const getSchemaOptions = (customHeaders) => ({
    headers: { ...options.headers, ...customHeaders },
    skipGraphQLImport: false,
    descriptions: false,
    customFetch: fetch
  });
  const leftSchemaOptions = getSchemaOptions((_a = options.leftSchema) == null ? void 0 : _a.headers);
  const rightSchemaOptions = getSchemaOptions((_b = options.rightSchema) == null ? void 0 : _b.headers);
  let [leftSchema, rightSchema] = await Promise.all([
    loadSchema(leftSchemaLocation2, {
      loaders: [new UrlLoader(), new JsonFileLoader(), new GraphQLFileLoader()],
      ...leftSchemaOptions
    }),
    loadSchema(rightSchemaLocation2, {
      loaders: [new UrlLoader(), new JsonFileLoader(), new GraphQLFileLoader()],
      ...rightSchemaOptions
    })
  ]);
  if (!leftSchema || !rightSchema) {
    throw new Error("Schemas not defined");
  }
  if (options.sortSchema) {
    [leftSchema, rightSchema] = [
      lexicographicSortSchema(leftSchema),
      lexicographicSortSchema(rightSchema)
    ];
  }
  const [leftSchemaSDL, rightSchemaSDL] = [
    printSchemaWithDirectives(leftSchema),
    printSchemaWithDirectives(rightSchema)
  ];
  if (leftSchemaSDL === rightSchemaSDL) {
    return;
  }
  const diff = disparity.unified(leftSchemaSDL, rightSchemaSDL, {
    paths: [leftSchemaLocation2, rightSchemaLocation2]
  });
  const diffNoColor = disparity.unifiedNoColor(leftSchemaSDL, rightSchemaSDL, {
    paths: [leftSchemaLocation2, rightSchemaLocation2]
  });
  const dangerousChanges = findDangerousChanges(leftSchema, rightSchema);
  const breakingChanges = findBreakingChanges(leftSchema, rightSchema);
  return {
    diff,
    diffNoColor,
    dangerousChanges,
    breakingChanges
  };
}

// src/cli.ts
var cli = meow(
  `
  Usage
    $ graphql-schema-diff <leftSchemaLocation> <rightSchemaLocation>

  Options
    --fail-on-dangerous-changes  Exit with error on dangerous changes
    --fail-on-breaking-changes 	 Exit with error on breaking changes
    --fail-on-all-changes 	 Exit with error on all changes
    --create-html-output 	 Creates an HTML file containing the diff
    --html-output-directory 	 Directory where the HTML file should be stored (Default: './schemaDiff')
    --header, -H 		 Header to send to all remote schema sources
    --left-schema-header 	 Header to send to left remote schema source
    --right-schema-header 	 Header to send to right remote schema source
    --sort-schema, -s 		 Sort schemas prior to diffing

  Examples
    $ graphql-schema-diff https://example.com/graphql schema.graphql
    $ graphql-schema-diff https://example.com/graphql schema.graphql -H 'Authorization: Bearer 123'
`,
  {
    flags: {
      failOnDangerousChanges: {
        type: "boolean"
      },
      failOnBreakingChanges: {
        type: "boolean"
      },
      failOnAllChanges: {
        type: "boolean"
      },
      // Deprecated: chalk.supportsColor should be used instead
      useColors: {
        type: "boolean"
      },
      createHtmlOutput: {
        type: "boolean"
      },
      htmlOutputDirectory: {
        type: "string",
        default: "schemaDiff"
      },
      header: {
        type: "string",
        alias: "H"
      },
      leftSchemaHeader: {
        type: "string"
      },
      rightSchemaHeader: {
        type: "string"
      },
      sortSchema: {
        type: "boolean",
        alias: "s"
      },
      help: {
        alias: "h"
      },
      version: {
        alias: "v"
      }
    }
  }
);
function parseHeaders(headerInput) {
  let headers;
  const parseHeader = (header2) => header2.split(":").map((val) => val.trim());
  if (!headerInput)
    return;
  if (Array.isArray(headerInput)) {
    headers = headerInput.map(parseHeader);
  } else {
    headers = [parseHeader(headerInput)];
  }
  return headers.reduce(
    (result, [key, value]) => ({
      ...result,
      ...key && value && { [key]: value }
    }),
    {}
  );
}
var [leftSchemaLocation, rightSchemaLocation] = cli.input;
var {
  header,
  leftSchemaHeader,
  rightSchemaHeader
} = cli.flags;
if (!leftSchemaLocation || !rightSchemaLocation) {
  console.error(
    chalk.red("ERROR: Schema locations missing!\n\n"),
    chalk.gray(
      "Usage\n  $ graphql-schema-diff <leftSchemaLocation> <rightSchemaLocation>"
    )
  );
  process.exit(1);
}
getDiff(leftSchemaLocation, rightSchemaLocation, {
  headers: parseHeaders(header),
  leftSchema: {
    headers: parseHeaders(leftSchemaHeader)
  },
  rightSchema: {
    headers: parseHeaders(rightSchemaHeader)
  },
  sortSchema: cli.flags.sortSchema
}).then(async (result) => {
  if (result === void 0) {
    console.warn(chalk.green("\u2714 No changes"));
    return;
  }
  const hasBreakingChanges = result.breakingChanges.length !== 0;
  const hasDangerousChanges = result.dangerousChanges.length !== 0;
  if (cli.flags.useColors || chalk.supportsColor) {
    console.log(result.diff);
  } else {
    console.log(result.diffNoColor);
  }
  if (hasDangerousChanges) {
    console.warn(chalk.yellow.bold.underline("Dangerous changes"));
    for (const change of result.dangerousChanges) {
      console.warn(chalk.yellow("  \u26A0 " + change.description));
    }
  }
  if (hasDangerousChanges && hasBreakingChanges) {
    console.warn();
  }
  if (hasBreakingChanges) {
    console.warn(chalk.red.bold.underline("BREAKING CHANGES"));
    for (const change of result.breakingChanges) {
      console.warn(chalk.red("  \u2716 " + change.description));
    }
  }
  if (cli.flags.createHtmlOutput) {
    await createHtmlOutput(result.diffNoColor, {
      outputDirectory: cli.flags.htmlOutputDirectory
    });
  }
  if (hasDangerousChanges && cli.flags.failOnDangerousChanges || hasBreakingChanges && cli.flags.failOnBreakingChanges || cli.flags.failOnAllChanges) {
    process.exit(1);
    return;
  }
}).catch((err) => {
  console.error(chalk.red(`
ERROR: ${err.message}`));
  process.exit(1);
});
